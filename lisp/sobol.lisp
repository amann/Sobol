(defpackage #:sobol
  (:nicknames #:s)
  (:use #:cl))

(in-package #:sobol)

(defun read-polynomials (file dimension)
  (with-open-file (*standard-input* file)
    (read-line)
    (do* ((d 1 (read))
          (s 32 (read))
          (a 0 (read))
          (m (make-array s :initial-element 1)
             (let ((m (make-array s)))
               (dotimes (i s m)
                 (setf (svref m i) (read)))))
          (result (list (cons a m))
                  (cons (cons a m) result)))
         ((<= dimension d) (nreverse result)))))

(defun compute-direction-numbers (polynomials nbr-points)
  (declare (optimize (speed 3) (debug 0))
           (type (unsigned-byte 32) nbr-points))
  (let ((l (integer-length nbr-points))
        result)
    (dolist (item polynomials (coerce (nreverse result) 'vector))
      (push (let* ((a (car item))
                   (m (cdr item))
                   (s (length m))
                   (v (make-array l)))
              (declare (type simple-vector m)
                       (type (unsigned-byte 8) s))
              (dotimes (k (min l s))
                (setf (svref v k) (the (unsigned-byte 32) (ash (the (unsigned-byte 32) (svref m k)) (- 31 k)))))
              (dotimes (k (- l s) v)
                (let* ((v_k (svref v k))
                       (v_k+s (logxor v_k (ash v_k (- s))))
                       (k+s (+ k s))
                       (k+s-1 (- k+s 1)))
                  (declare (type (unsigned-byte 32) v_k v_k+s k k+s k+s-1))
                  (setf (svref v k+s)
                        (dotimes (r (- s 1) v_k+s)
                          (setf v_k+s
                                (logxor v_k+s
                                        (if (ldb-test (byte 1 (- s 2 r))
                                                      a)
                                            (the (unsigned-byte 32) (svref v (- k+s-1 r)))
                                            0))))))))
            result))))

(declaim (ftype (function ((unsigned-byte 32)) (unsigned-byte 8))))
(defun zero@idx (integer)
  (declare (type (unsigned-byte 32) integer)
           (optimize (speed 3) (safety 3) (debug 0)))
  (do ((idx 0 (1+ idx)))
      ((not (ldb-test (byte 1 idx) (the (unsigned-byte 32) integer))) idx)
    (declare ((unsigned-byte 8) idx))))

(defun sobol-points (nbr-points dimension file)
  (declare (optimize (speed 3) (debug 0))
           (type (unsigned-byte 32) nbr-points dimension))
  (let ((grid (make-array dimension :initial-contents (let (arrays)
                                                        (dotimes (i dimension arrays)
                                                          (push (make-array nbr-points) arrays))))))
    (let ((direction-numbers (compute-direction-numbers (read-polynomials file dimension)
                                                        nbr-points))
          (2^31 (expt 2 31)))
      (dotimes (d (length direction-numbers) grid)
        (let ((v (svref direction-numbers d))
              (x_d (svref grid d))
              (x 0))
          (declare (type (unsigned-byte 32) x))
          (dotimes (n nbr-points)
            (setf (svref x_d n) (- (setf x (logxor x (the (unsigned-byte 32) (svref v (zero@idx n)))))
                                   2^31))))))))

(defun mean (sequence)
  (let* ((count 0)
         (sum (reduce (lambda (r x)
                        (incf count)
                        (+ r x))
                      sequence
                      :initial-value 0)))
    (if (zerop count)
        0
        (/ sum count))))

(declaim (type simple-vector *sobol*))
(defparameter *sobol* (sobol-points (1- (expt 2 9)) (expt 2 12) #p"../new-joe-kuo-6.21201"))

(defun check-corr ()
  (let* ((max 0)
         (dim (length *sobol*))
         (prod (make-array (length (svref *sobol* 0))))
         (sum (* 1/4 (expt 2 32) dim)))
    (dotimes (i dim (/ max sum))
      (let ((sobol_i (svref *sobol* i)))
        (dotimes (j i)
          (setf max (max max (abs (- (reduce '+ (map-into prod '*
                                                          sobol_i
                                                          (svref *sobol* j)))
                                     sum)))))
        (when (zerop (mod i 100))
          (format t "~%~A: ~A" i (/ max sum)))))))

(defun correlation-matrix ()
  (declare (optimize (speed 3) (debug 0)))
  (let* ((sobol-0 (svref *sobol* 0))
         (n (length sobol-0))
         (dim (length *sobol*))
         (prod (make-array n)))
    (declare (type simple-vector *sobol* sobol-0))
    (flet ((sum-xy (x y) (reduce (lambda (r xy)
                                   (declare (type (signed-byte 128) r)
                                            (type (signed-byte 64) xy))
                                   (+ r xy))
                                 (map-into prod (lambda (x y)
                                                  (declare (type (signed-byte 32) x y))
                                                  (the (signed-byte 64) (* x y)))
                                           x y)
                                 :initial-value 0)))
      (declare (ftype (function (simple-vector simple-vector) (signed-byte 128)) sum-xy))
      (let ((sum-x_i^2 (coerce (sum-xy sobol-0 sobol-0) 'double-float)))
        (declare (type double-float sum-x_i^2))
        (map-into (make-array dim)
                  (lambda (sobol-i)
                    (declare (type simple-vector sobol-i))
                    (map-into (make-array dim)
                              (lambda (sobol-j)
                                (declare (type simple-vector sobol-j))
                                (/ (the (signed-byte 128) (sum-xy sobol-i sobol-j))
                                   (the double-float sum-x_i^2)))
                              *sobol*))
                  *sobol*)))))



(defun classify-correlations ()
  (declare (optimize (speed 3) (debug 0)))
  (let ((hash (make-hash-table))
        (dim (length *sobol*))
        (correlation-matrix (correlation-matrix)))
    (dotimes (i dim)
      (dotimes (j i)
        (push j (getf (gethash (abs (the rational (svref (svref correlation-matrix j) i))) hash)
                      i))))
    (let (result)
      (maphash (lambda (k v)
                 (push (cons k (list v)) result))
               hash)
      (sort result '> :key 'car))))

